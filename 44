/****************************************************
 *
 * content-all.js (Manifest V3, контент-скрипт)
 *
 * «Скрипт 08», но теперь вместо «копирования в Я.Диск» 
 * отправляем файлы (через ссылки) на локальный Python-сервер для скачивания.
 *
 * Хранение базы: IndexedDB — только в background.js.
 ****************************************************/

/* ==========================
   0. ГЛОБАЛЬНЫЕ
   ========================== */

// В памяти (для подсветки, чекбоксов и пр.)
let database = [];
let lastSyncModified = '1970-01-01T00:00:00Z';

// Токен Я.Диска (используем только в getPublicLinkForFile)
const YANDEX_TOKEN = 'y0_';

// Ключ для localStorage
const LAST_SYNC_KEY = 'lastSyncModifiedCombined';

// Определяем, где мы (Ozon или Wildberries)
const isOzon = window.location.host.includes('ozon');
const isWB   = window.location.host.includes('wildberries');

// Флаг автосинхронизации
let autoSyncEnabled = true;

// Массив выбранных артикулов (через чекбоксы)
let selectedArticles = []; // [{ id, article, number }, ...]


/* ==========================
   1. СВЯЗЬ С BACKGROUND (IndexedDB)
   ========================== */
function getAllFilesFromBackground() {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({ action: 'getAllFiles' }, (response) => {
      if (chrome.runtime.lastError) {
        return reject(new Error(chrome.runtime.lastError.message));
      }
      if (!response) {
        return reject(new Error('Нет ответа от background'));
      }
      if (response.success) {
        resolve(response.files);
      } else {
        reject(new Error(response.error || 'Unknown error'));
      }
    });
  });
}

function putFileToBackground(fileObj) {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({ action: 'putFile', file: fileObj }, (response) => {
      if (chrome.runtime.lastError) {
        return reject(new Error(chrome.runtime.lastError.message));
      }
      if (!response) {
        return reject(new Error('Нет ответа'));
      }
      if (response.success) {
        resolve(response.key);
      } else {
        reject(new Error(response.error));
      }
    });
  });
}

function clearFilesInBackground() {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({ action: 'clearFiles' }, (response) => {
      if (chrome.runtime.lastError) {
        return reject(new Error(chrome.runtime.lastError.message));
      }
      if (!response) {
        return reject(new Error('Нет ответа от background'));
      }
      if (response.success) {
        resolve();
      } else {
        reject(new Error(response.error));
      }
    });
  });
}

function deleteFileInBackground(fileName) {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({ action: 'deleteFile', fileName }, (response) => {
      if (chrome.runtime.lastError) {
        return reject(new Error(chrome.runtime.lastError.message));
      }
      if (!response) {
        return reject(new Error('Нет ответа'));
      }
      if (response.success) {
        resolve();
      } else {
        reject(new Error(response.error));
      }
    });
  });
}


/* ==========================
   2. ЗАГРУЗКА / СОХРАНЕНИЕ
   ========================== */
function updateFileCount() {
  const fileCountSpan = document.getElementById('file-count');
  if (!fileCountSpan) return;
  fileCountSpan.textContent = `Всего файлов в базе: ${database.length}`;
}

async function loadDataFromBackground() {
  try {
    const all = await getAllFilesFromBackground();
    database = all || [];
    console.log('[content-all.js] Загружено из IDB:', database.length, 'файлов');

    lastSyncModified = localStorage.getItem(LAST_SYNC_KEY) || '1970-01-01T00:00:00Z';
  } catch (err) {
    console.error('Ошибка чтения из background/IndexedDB:', err);
  }
}

function saveLastSyncModified(value) {
  lastSyncModified = value;
  localStorage.setItem(LAST_SYNC_KEY, value);
}

async function addToDatabase(fileName, created, modified, path) {
  const newObj = { name: fileName, uploadedAt: created, modified, path };
  database.push(newObj);

  try {
    await putFileToBackground(newObj);
  } catch (err) {
    console.error('[addToDatabase] ошибка putFileToBackground:', err);
    if (err.message === 'DB not open') {
      showToast('Ошибка: база не открыта!', 'error');
      database = database.filter(f => f.name !== newObj.name);
    } else {
      showToast(`Ошибка при сохранении файла: ${err.message}`, 'error');
    }
  }
}

async function resetDatabase() {
  database = [];
  await clearFilesInBackground();
  saveLastSyncModified('1970-01-01T00:00:00Z');
}


/* ==========================
   3. СОЗДАНИЕ UI (ПАНЕЛЬ)
   ========================== */
function createUI() {
  if (document.getElementById('side-panel')) return;

  const sidePanel = document.createElement('div');
  sidePanel.id = 'side-panel';
  sidePanel.style.position = 'fixed';
  sidePanel.style.top = '40px';
  sidePanel.style.right = '20px';
  sidePanel.style.width = '320px';
  sidePanel.style.backgroundColor = '#f9f9f9';
  sidePanel.style.border = '1px solid #ccc';
  sidePanel.style.borderRadius = '6px';
  sidePanel.style.padding = '12px';
  sidePanel.style.zIndex = '999999';
  sidePanel.style.boxShadow = '0 4px 16px rgba(0,0,0,0.15)';
  sidePanel.style.fontFamily = 'Arial, sans-serif';
  sidePanel.style.color = '#333';
  sidePanel.style.cursor = 'default';

  document.body.appendChild(sidePanel);

  const title = document.createElement('h3');
  title.textContent = isOzon ? 'Скрипт (Ozon)' : 'Скрипт (Wildberries)';
  title.style.marginBottom = '15px';
  title.style.fontSize = '20px';
  title.style.cursor = 'move';
  sidePanel.appendChild(title);

  // Кнопка «Скачать локально»
  const localDownloadBtn = document.createElement('button');
  localDownloadBtn.textContent = 'Скачать в папку';
  localDownloadBtn.style.display = 'block';
  localDownloadBtn.style.marginBottom = '10px';
  localDownloadBtn.style.padding = '12px';
  localDownloadBtn.style.border = 'none';
  localDownloadBtn.style.borderRadius = '5px';
  localDownloadBtn.style.cursor = 'pointer';
  localDownloadBtn.style.width = '100%';
  localDownloadBtn.style.fontSize = '14px';
  localDownloadBtn.style.backgroundColor = '#7a6eb5';
  localDownloadBtn.style.color = '#fff';
  localDownloadBtn.style.transition = 'background-color 0.2s';

  localDownloadBtn.addEventListener('mouseover', () => {
    localDownloadBtn.style.backgroundColor = '#6b61a4';
  });
  localDownloadBtn.addEventListener('mouseout', () => {
    localDownloadBtn.style.backgroundColor = '#7a6eb5';
  });
  localDownloadBtn.addEventListener('click', collectArticlesInFolder);
  sidePanel.appendChild(localDownloadBtn);

  // Пример: кнопка «Открыть папку»
const openFolderBtn = document.createElement('button');
openFolderBtn.id = 'open-folder-button';
openFolderBtn.textContent = 'Открыть папку';
openFolderBtn.style.display = 'block';
openFolderBtn.style.marginBottom = '10px';
openFolderBtn.style.padding = '12px';
openFolderBtn.style.border = 'none';
openFolderBtn.style.borderRadius = '5px';
openFolderBtn.style.cursor = 'pointer';
openFolderBtn.style.width = '100%';
openFolderBtn.style.fontSize = '14px';
openFolderBtn.style.backgroundColor = '#7a6eb5';
openFolderBtn.style.color = '#fff';
  sidePanel.appendChild(openFolderBtn);
  openFolderBtn.addEventListener('click', async () => {
  try {
    // Путь к папке берём из localStorage 
    // (или жёстко прописываем, если нужно):
    const folderToOpen = localStorage.getItem('lastFolderPath') 
                       || 'D:\\Новая папка\\ПЕЧАТИ'; // пример

    // Запрос на локальный сервер
    const resp = await fetch("http://127.0.0.1:5000/open_folder", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ folderPath: folderToOpen })
    });

    if (!resp.ok) {
      const txt = await resp.text();
      showToast(`Не удалось открыть папку: ${resp.status} ${txt}`, 'error');
    } else {
      const data = await resp.json();
      if (data.error) {
        showToast(`Ошибка при открытии папки: ${data.error}`, 'error');
      } else {
        showToast(`Папка открыта: ${data.folderPath}`, 'success');
      }
    }
  } catch (err) {
    showToast(`Исключение при открытии папки: ${err.message}`, 'error');
    console.error(err);
  }
});


// Добавляем кнопку в интерфейс
sidePanel.appendChild(openFolderBtn);



  // Счётчик выбранных
  const countSpan = document.createElement('span');
  countSpan.id = 'article-counter';
  countSpan.style.display = 'block';
  countSpan.style.marginTop = '10px';
  countSpan.style.fontSize = '15px';
  countSpan.textContent = 'Выбрано: 0';
  sidePanel.appendChild(countSpan);

  // Счётчик файлов
  const fileCountSpan = document.createElement('span');
  fileCountSpan.id = 'file-count';
  fileCountSpan.style.display = 'block';
  fileCountSpan.style.marginTop = '5px';
  fileCountSpan.style.fontSize = '15px';
  fileCountSpan.textContent = `Всего файлов в базе: ${database.length}`;
  sidePanel.appendChild(fileCountSpan);

  // Прогресс-бар
  const progressContainer = document.createElement('div');
  progressContainer.id = 'collect-progress-container';
  progressContainer.style.width = '100%';
  progressContainer.style.height = '24px';
  progressContainer.style.backgroundColor = '#eee';
  progressContainer.style.borderRadius = '12px';
  progressContainer.style.position = 'relative';
  progressContainer.style.marginTop = '10px';

  const progressFill = document.createElement('div');
  progressFill.id = 'collect-progress-fill';
  progressFill.style.width = '0%';
  progressFill.style.height = '100%';
  progressFill.style.backgroundColor = '#2196F3';
  progressFill.style.borderRadius = '12px';

  const progressLabel = document.createElement('div');
  progressLabel.id = 'collect-progress-label';
  progressLabel.style.position = 'absolute';
  progressLabel.style.top = '0';
  progressLabel.style.left = '50%';
  progressLabel.style.transform = 'translateX(-50%)';
  progressLabel.style.color = '#fff';
  progressLabel.style.fontWeight = 'bold';
  progressLabel.style.lineHeight = '24px';
  progressLabel.textContent = '0%';

  progressContainer.appendChild(progressFill);
  progressContainer.appendChild(progressLabel);
  sidePanel.appendChild(progressContainer);
  

  // Блок «Обновить базу» + «Скачать CSV»
  const splittedContainer = document.createElement('div');
  splittedContainer.style.display = 'flex';
  splittedContainer.style.gap = '5px';
  splittedContainer.style.marginTop = '12px';

  let isSyncing = false;
  const commonButtonStyle = {
    flex: '1',
    padding: '8px 5px',
    fontSize: '13px',
    border: 'none',
    borderRadius: '5px',
    cursor: 'pointer',
    backgroundColor: '#6495ED',
    color: '#fff',
    transition: 'background-color 0.2s'
  };

  const refreshBtn = document.createElement('button');
  refreshBtn.textContent = 'Обновить базу';
  Object.assign(refreshBtn.style, commonButtonStyle);
  refreshBtn.addEventListener('mouseover', () => {
    refreshBtn.style.backgroundColor = '#5787cc';
  });
  refreshBtn.addEventListener('mouseout', () => {
    refreshBtn.style.backgroundColor = '#6495ED';
  });

  refreshBtn.addEventListener('click', async () => {
    if (isSyncing) {
      showToast('База уже обновляется, дождитесь завершения', 'info');
      return;
    }
    isSyncing = true;
    showToast('Начинаем обновление базы (полный сброс)...', 'info');

    try {
      await resetDatabase();
      await syncFilesToDatabase();
      showToast('База полностью обновлена!', 'success');
    } catch(err) {
      console.error('Ошибка при обновлении базы:', err);
      showToast(`Ошибка: ${err.message}`, 'error');
    } finally {
      isSyncing = false;
    }
  });
  splittedContainer.appendChild(refreshBtn);

  const exportBtn = document.createElement('button');
  exportBtn.textContent = 'Скачать CSV';
  Object.assign(exportBtn.style, commonButtonStyle);
  exportBtn.addEventListener('mouseover', () => {
    exportBtn.style.backgroundColor = '#5787cc';
  });
  exportBtn.addEventListener('mouseout', () => {
    exportBtn.style.backgroundColor = '#6495ED';
  });
  exportBtn.addEventListener('click', exportToCSV);
  splittedContainer.appendChild(exportBtn);

  sidePanel.appendChild(splittedContainer);

  // «Автосинхронизация»
  const syncToggleContainer = document.createElement('div');
  syncToggleContainer.style.marginTop = '10px';
  syncToggleContainer.style.display = 'flex';
  syncToggleContainer.style.alignItems = 'center';
  syncToggleContainer.style.justifyContent = 'space-between';

  const syncLabel = document.createElement('label');
  syncLabel.textContent = 'Автосинхронизация';
  syncToggleContainer.appendChild(syncLabel);

  const switchLabel = document.createElement('label');
  switchLabel.style.display = 'inline-block';
  switchLabel.style.width = '40px';
  switchLabel.style.height = '22px';
  switchLabel.style.position = 'relative';

  const syncCheckbox = document.createElement('input');
  syncCheckbox.type = 'checkbox';
  syncCheckbox.checked = true;
  autoSyncEnabled = true;
  syncCheckbox.style.position = 'absolute';
  syncCheckbox.style.opacity = '0';
  syncCheckbox.style.width = '0';
  syncCheckbox.style.height = '0';

  syncCheckbox.addEventListener('change', () => {
    autoSyncEnabled = syncCheckbox.checked;
    showToast(
      autoSyncEnabled ? 'Автосинхронизация включена' : 'Автосинхронизация отключена',
      'info'
    );
    if (autoSyncEnabled) {
      startSyncSpinnerCountdown(60);
    } else {
      stopSyncSpinner();
    }
  });

  const sliderSpan = document.createElement('span');
  sliderSpan.style.position = 'absolute';
  sliderSpan.style.cursor = 'pointer';
  sliderSpan.style.top = '0';
  sliderSpan.style.left = '0';
  sliderSpan.style.right = '0';
  sliderSpan.style.bottom = '0';
  sliderSpan.style.backgroundColor = '#ccc';
  sliderSpan.style.borderRadius = '22px';
  sliderSpan.style.transition = '.4s';

  const beforeSpan = document.createElement('span');
  beforeSpan.style.position = 'absolute';
  beforeSpan.style.height = '16px';
  beforeSpan.style.width = '16px';
  beforeSpan.style.left = '3px';
  beforeSpan.style.bottom = '3px';
  beforeSpan.style.backgroundColor = 'white';
  beforeSpan.style.borderRadius = '50%';
  beforeSpan.style.transition = '.4s';

  sliderSpan.appendChild(beforeSpan);
  if (syncCheckbox.checked) {
    sliderSpan.style.backgroundColor = '#6495ED';
    beforeSpan.style.transform = 'translateX(18px)';
  }
  syncCheckbox.addEventListener('change', () => {
    if (syncCheckbox.checked) {
      sliderSpan.style.backgroundColor = '#6495ED';
      beforeSpan.style.transform = 'translateX(18px)';
    } else {
      sliderSpan.style.backgroundColor = '#ccc';
      beforeSpan.style.transform = 'translateX(0px)';
    }
  });

  switchLabel.appendChild(syncCheckbox);
  switchLabel.appendChild(sliderSpan);
  syncToggleContainer.appendChild(switchLabel);
  sidePanel.appendChild(syncToggleContainer);

  // «Спиннер»
  const syncSpinner = document.createElement('div');
  syncSpinner.id = 'sync-spinner';
  syncSpinner.style.border = '4px solid rgba(0,0,0,0.1)';
  syncSpinner.style.width = '24px';
  syncSpinner.style.height = '24px';
  syncSpinner.style.borderRadius = '50%';
  syncSpinner.style.borderLeftColor = '#6495ED';
  syncSpinner.style.margin = '10px auto';
  syncSpinner.style.display = 'block';
  syncSpinner.style.animation = 'spin 10s linear infinite';
  sidePanel.appendChild(syncSpinner);

  // Анимация spin (CSS)
  const styleEl = document.createElement('style');
  styleEl.innerHTML = `
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  `;
  document.head.appendChild(styleEl);

  makePanelDraggable(sidePanel, title);
}


/* ==========================
   4. УТИЛИТЫ / ПОДСВЕТКА
   ========================== */
function makePanelDraggable(panelEl, handleEl) {
  let isDragging = false;
  let offsetX = 0;
  let offsetY = 0;

  handleEl.addEventListener('mousedown', (e) => {
    isDragging = true;
    offsetX = e.clientX - panelEl.offsetLeft;
    offsetY = e.clientY - panelEl.offsetTop;
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const newLeft = e.clientX - offsetX;
    const newTop  = e.clientY - offsetY;
    panelEl.style.left = `${newLeft}px`;
    panelEl.style.top  = `${newTop}px`;
  });

  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
}

function sanitizeFileName(name) {
  return name.replace(/[\/\\:*?"<>|]/g, '_');
}

function shouldIgnoreFile(filePath, fileName) {
  const lowerName = (fileName || '').toLowerCase();
  if (filePath.includes('/печати/')) return true;
  if (lowerName.includes('_oz') || lowerName.includes('_wb')) return true;
  return false;
}

function extractBase(str) {
  const withoutExt = str.replace(/\.[^.]+$/, '');
  const parts = withoutExt.split(/\s+/);
  return parts[0];
}

function hasModuleSuffix(name) {
  const lower = name.toLowerCase().replace(/\s+/g, '');
  return /\d+ип/.test(lower);
}

function getCurrentSellerName() {
  if (!isWB) return '';
  const sellerSpans = Array.from(document.querySelectorAll('span[data-name="Text"]'));
  const sellerSpan = sellerSpans.find(span => span.textContent.includes('ИП'));
  if (sellerSpan) {
    const sellerName = sellerSpan.textContent.trim()
      .replace(/^ИП\s+/i, '')
      .replace(/\s+/g, '_');
    console.log('Имя продавца найдено:', sellerName);
    return sellerName;
  } else {
    console.log('Имя продавца не найдено');
    return 'Неизвестный_продавец';
  }
}

function autoHighlightOzon() {
  const articleLinks = document.querySelectorAll('a.link-module_link_91e5F');
  articleLinks.forEach(aEl => {
    const article = aEl.textContent.trim();
    const matched = database.filter(f => extractBase(f.name) === extractBase(article));

    aEl.style.backgroundColor = 'transparent';
    aEl.style.borderRadius = '0';

    if (matched.length === 0) {
      aEl.style.backgroundColor = 'rgba(255, 0, 0, 0.2)';
    } else if (matched.length === 1) {
      aEl.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
    } else {
      const someIp   = matched.some(file => hasModuleSuffix(file.name));
      const someNoIp = matched.some(file => !hasModuleSuffix(file.name));
      if (someIp && someNoIp) {
        aEl.style.backgroundColor = 'rgba(255, 165, 0, 0.3)';
      } else {
        aEl.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
      }
    }
    aEl.style.borderRadius = '5px';
  });
}

function getArticleFromRowWB(cardEl) {
  const span = cardEl.querySelector(
    'span[data-testid="Item-table-cell-text"], span[data-testid="Order-info-article-text"]'
  );
  if (!span) return '—';
  const txt = span.textContent.trim();
  return extractBase(txt.replace(/^Арт\.\s*/i, ''));
}

function autoHighlightWB() {
  const cardEls = document.querySelectorAll(
    'div.Table-row-view__wk354Ab8Rh, div.Tasks-card-view__card-content'
  );
  cardEls.forEach(cardEl => {
    const articleSpan = cardEl.querySelector(
      'span[data-testid="Item-table-cell-text"], span[data-testid="Order-info-article-text"]'
    );
    if (!articleSpan) return;

    const article = getArticleFromRowWB(cardEl);
    const matched = database.filter(f => extractBase(f.name) === extractBase(article));

    articleSpan.style.backgroundColor = 'transparent';
    articleSpan.style.borderRadius = '0';

    if (matched.length === 0) {
      articleSpan.style.backgroundColor = 'rgba(255, 0, 0, 0.2)';
    } else if (matched.length === 1) {
      articleSpan.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
    } else {
      const someIp   = matched.some(file => hasModuleSuffix(file.name));
      const someNoIp = matched.some(file => !hasModuleSuffix(file.name));
      if (someIp && someNoIp) {
        articleSpan.style.backgroundColor = 'rgba(255, 165, 0, 0.3)';
      } else {
        articleSpan.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
      }
    }
    articleSpan.style.borderRadius = '5px';
  });
}

function autoHighlightAllArticles() {
  if (isOzon) {
    autoHighlightOzon();
  } else if (isWB) {
    autoHighlightWB();
  }
}

function initMutationObserver() {
  const container = document.querySelector('#app') || document.body;
  if (!container) {
    console.warn('MutationObserver: контейнер не найден!');
    return;
  }

  let mutationTimer = null;
  const observer = new MutationObserver(() => {
    if (mutationTimer) clearTimeout(mutationTimer);
    mutationTimer = setTimeout(() => {
      autoHighlightAllArticles();
    }, 150);
  });

  observer.observe(container, { childList: true, subtree: true });
}


/* ==========================
   5. TOAST (уведомления)
   ========================== */
function showToast(message, type = 'info') {
  const tc = getToastContainer();

  const toast = document.createElement('div');
  toast.textContent = message;

  // Общий «широкий» и "невысокий" стиль
  toast.style.display = 'inline-block';
  toast.style.padding = '8px 20px';
  toast.style.marginBottom = '8px'; // отступ между тостами
  toast.style.borderRadius = '6px';
  toast.style.fontSize = '14px';
  toast.style.lineHeight = '1.3';
  toast.style.color = '#fff';
  toast.style.fontFamily = 'Arial, sans-serif';
  toast.style.boxShadow = '0 2px 5px rgba(0,0,0,0.3)';
  toast.style.opacity = '1';
  toast.style.transition = 'opacity 0.4s';
  toast.style.maxWidth = '400px';

  // Цвет фона по типу
  if (type === 'success') {
    toast.style.backgroundColor = '#4CAF50'; // зелёный
  } else if (type === 'error') {
    toast.style.backgroundColor = '#F44336'; // красный
  } else if (type === 'warning') {
    toast.style.backgroundColor = '#ff9800'; // оранжевый
  } else {
    // По умолчанию «info» = синий
    toast.style.backgroundColor = '#2196F3';
  }

  // Добавляем toast в начало контейнера
  // Чтобы новые оказывались снизу «под» предыдущими,
  // используем column-reverse + insertBefore(...)
  tc.insertBefore(toast, tc.firstChild);

  // Через 4 секунды скрываем
  setTimeout(() => {
    toast.style.opacity = '0';
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 400);
  }, 4000);
}

/**
 * Создаёт (или возвращает) контейнер для тостов.
 * Контейнер фиксирован в правом нижнем углу,
 * и укладывает элементы снизу вверх (column-reverse).
 */
function getToastContainer() {
  let tc = document.getElementById('toast-container');
  if (!tc) {
    tc = document.createElement('div');
    tc.id = 'toast-container';

    // Размещение в правом нижнем углу
    tc.style.position = 'fixed';
    tc.style.bottom = '20px';
    tc.style.right = '20px';
    tc.style.zIndex = '999999';

    // Включаем флекс и column-reverse, 
    // чтобы новый тост оказывался «внизу» предыдущих
    tc.style.display = 'flex';
    tc.style.flexDirection = 'column-reverse';

    document.body.appendChild(tc);
  }
  return tc;
}

/* ==========================
   6. СИНХРОНИЗАЦИЯ с Я.Диском
   ========================== */
async function fetchAllFiles() {
  console.log('[fetchAllFiles] Начинаем полную загрузку…');

  let files = [];
  let offset = 0;
  const limit = 1000;

  while (true) {
    const url = `https://cloud-api.yandex.net/v1/disk/resources/files?limit=${limit}&offset=${offset}`;
    const headers = { 'Authorization': `OAuth ${YANDEX_TOKEN}` };

    const resp = await fetch(url, { method: 'GET', headers });
    if (!resp.ok) {
      const text = await resp.text();
      console.error(`[fetchAllFiles] Error code=${resp.status}, text=${text}`);
      throw new Error(`[fetchAllFiles] Ошибка: ${resp.status} ${resp.statusText}`);
    }

    const data = await resp.json();
    const items = data.items || [];
    files = files.concat(items);
    console.log(`[fetchAllFiles] offset=${offset}, получено=${items.length}, всего=${files.length}`);

    if (items.length < limit) {
      break;
    }
    offset += limit;
  }

  console.log('[fetchAllFiles] Все порции получены, итого:', files.length, 'файлов');
  return files;
}

async function fetchNewOrUpdatedFiles() {
  let newOrUpdated = [];
  let offset = 0;
  const limit = 1000;
  const lastSyncDateObj = new Date(lastSyncModified);

  while(true) {
    const url = `https://cloud-api.yandex.net/v1/disk/resources/files?limit=${limit}&offset=${offset}&sort=-modified`;
    const headers = { 'Authorization': `OAuth ${YANDEX_TOKEN}` };

    const resp = await fetch(url, { method:'GET', headers });
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`fetchNewOrUpdatedFiles: ${txt}`);
    }
    const data = await resp.json();
    const items = data.items || [];
    if (items.length === 0) break;

    let stop = false;
    for (const file of items) {
      const mtime = new Date(file.modified);
      if (mtime <= lastSyncDateObj) {
        stop = true;
        break;
      }
      newOrUpdated.push(file);
    }
    if (stop || items.length < limit) break;
    offset += limit;
  }
  return newOrUpdated;
}

async function syncFilesToDatabase() {
  try {
    let addedCount = 0; 
    let maxModified = new Date(lastSyncModified);

    if (database.length === 0) {
      const all = await fetchAllFiles();
      console.log(`[syncFilesToDatabase] Полная загрузка: получено ${all.length} файлов`);

      for (const file of all) {
        if (isTifFormat(file.name) && !shouldIgnoreFile(file.path, file.name)) {
          if (!database.some(item => item.name === file.name)) {
            await addToDatabase(file.name, file.created, file.modified, file.path);
            addedCount++;
          }
          const m = new Date(file.modified);
          if (m > maxModified) maxModified = m;
        }
      }
      if (maxModified > new Date(lastSyncModified)) {
        saveLastSyncModified(maxModified.toISOString());
      }
      console.log(`[syncFilesToDatabase] Всего добавлено (первый запуск): ${addedCount}`);

    } else {
      const newFiles = await fetchNewOrUpdatedFiles();
      console.log(`[syncFilesToDatabase] Инкремент: получено ${newFiles.length} новых/обновлённых файлов`);

      if (newFiles.length === 0) {
        updateFileCount();
        autoHighlightAllArticles();
        console.log(`[syncFilesToDatabase] База не изменилась, всего: ${database.length} файлов`);
        return;
      }

      for (const file of newFiles) {
        if (isTifFormat(file.name) && !shouldIgnoreFile(file.path, file.name)) {
          if (!database.some(item => item.name === file.name)) {
            await addToDatabase(file.name, file.created, file.modified, file.path);
            addedCount++;
          }
          const m = new Date(file.modified);
          if (m > maxModified) maxModified = m;
        }
      }
      if (maxModified > new Date(lastSyncModified)) {
        saveLastSyncModified(maxModified.toISOString());
      }
      console.log(`[syncFilesToDatabase] За этот сеанс добавлено: ${addedCount}`);

      if (addedCount > 0) {
        showToast(`Дизайнер добавил новые файлы: ${addedCount} шт.`, 'info');
      }
    }

    updateFileCount();
    autoHighlightAllArticles();

  } catch (e) {
    showToast(`syncFilesToDatabase error: ${e.message}`, 'error');
  }
}

function isTifFormat(name) {
  return name.toLowerCase().endsWith('.tif');
}
/**
 * updateCollectProgressBar(current, total)
 * - current: число уже обработанных
 * - total: общее число
 * Обновляет #collect-progress-fill и #collect-progress-label
 */
function updateCollectProgressBar(current, total) {
  const fill = document.getElementById('collect-progress-fill');
  const label = document.getElementById('collect-progress-label');
  if (!fill || !label) return;

  if (total <= 0) {
    fill.style.width = '0%';
    label.textContent = '0%';
    return;
  }
  const percent = Math.round((current / total) * 100);
  fill.style.width = percent + '%';
  label.textContent = percent + '%';
}

/* ==========================
   7. «Скачать локально»
   ========================== */

/**
 * collectArticlesInFolder()
 * Собирает файлы по выбранным артиклам, 
 * показывает прогресс-бар при переборе,
 * и отправляет список на Python-сервер.
 */
 /** 
 * (B) ФУНКЦИЯ handleSelectAllWB(checked)
 * Когда «главный» чекбокс = true/false, хотим 
 * проставить/снять ВСЕ «строчные» чекбоксы на WB.
 */
function handleSelectAllWB(checked) {
  // 1) Ищем все «строчные» чекбоксы.
  //    Судя по вашему HTML, у них class="control__ZasAyXDOMH" 
  //    + type="checkbox",
  //    но мы исключим #checkbox-all, чтобы не трогать сам главный.
  const allItemCheckboxes = document.querySelectorAll(
    'input.control__ZasAyXDOMH[type="checkbox"]:not(#checkbox-all)'
  );
  console.log('[handleSelectAllWB] checked=', checked, 'нашли:', allItemCheckboxes.length);

  // 2) Проставляем .checked = true/false
  allItemCheckboxes.forEach(chk => {
    chk.checked = checked;

    // Если у вас есть «updateSelectedArticlesWB(...)»:
    //  (при клике на строчный чекбокс), можно вручную вызвать:
    updateSelectedArticlesWB(chk);
    //  чтобы массив selectedArticles, счётчик, etc. обновились
  });
}
async function collectArticlesInFolder() {
  // 1) Проверяем, есть ли выбранные артикулы
  if (selectedArticles.length === 0) {
    showToast('Нет выбранных артикулов', 'error');
    return;
  }
  console.log('[collectArticlesInFolder] Selected articles:', selectedArticles);

  // (A) Ставим прогресс на 0% (аргументы: текущий=0, всего=selectedArticles.length)
  updateCollectProgressBar(0, selectedArticles.length);

  // 2) Формируем имя папки
  const dateStr = new Date().toISOString().split('T')[0];
  let folderName = 'UnknownFolder';

  if (isWB) {
    const sellerName = getCurrentSellerName() || 'NoSeller';
    const supplyQR   = getSupplyQRCodeWB()   || 'NoQR';
    folderName = `ИП_${sellerName}_${dateStr}_${supplyQR}`;
  } else if (isOzon) {
    const firstArticle = selectedArticles[0]?.article || 'XX';
    const firstTwo     = firstArticle.substring(0, 2);
    folderName         = `${firstTwo}_${dateStr}`;
  }

  // Суффикс (WB / OZ)
  const suffix = isWB ? '_wb' : '_oz';

  // 3) Перебираем выбранные артикулы, ищем в базе, собираем allLinks
  const allLinks = [];
  let fileCounter = 0;
  const totalArticles = selectedArticles.length;

  for (let i = 0; i < totalArticles; i++) {
    // (B) Обновляем прогресс (i из 0..n-1)
    updateCollectProgressBar(i, totalArticles);

    const { article } = selectedArticles[i];
    const matched = database.filter(f => extractBase(f.name) === extractBase(article));

    if (matched.length === 0) {
      showToast(`Файл не найден в базе для артикула: ${article}`, 'error');
      continue;
    }
    else if (matched.length === 1) {
      const fileObj = matched[0];
      const url = await getPublicLinkForFile(fileObj);
      if (url && url !== '#') {
        fileCounter++;
        allLinks.push({ url, origName: fileObj.name });

        showToast(`Файл №${fileCounter} (артикул: ${article}) добавлен в очередь.`, 'info');
      }
    }
    else {
      // Несколько (оранжевый сценарий)
      const chosenFiles = await showIpModal(matched, article, 'без номера');
      if (chosenFiles.length === 0) {
        showToast(`Ничего не выбрано для артикула "${article}"`, 'warning');
        continue;
      }
      for (const fileObj of chosenFiles) {
        const url = await getPublicLinkForFile(fileObj);
        if (url && url !== '#') {
          fileCounter++;
          allLinks.push({ url, origName: fileObj.name });
          showToast(`Файл №${fileCounter} (артикул: ${article}) добавлен.`, 'info');
        }
      }
    }
  }

  // (C) После цикла ставим 100%
  updateCollectProgressBar(totalArticles, totalArticles);

  // 4) Если нет файлов — error
  if (allLinks.length === 0) {
    showToast('Нет файлов для скачивания', 'error');
    return;
  }

  // 5) Отправляем на Python /download
  try {
    showToast(`Подготовка к скачиванию: папка «${folderName}»...`, 'info');
    await downloadLocallyViaPython(allLinks, folderName, suffix);
    showToast(`Готово! Всего файлов для скачивания: ${allLinks.length}`, 'success');
  } catch (err) {
    console.error('[collectArticlesInFolder] Ошибка при отправке в Python:', err);
    showToast(`Ошибка скачивания: ${err.message}`, 'error');
  }
}

/**
 * downloadLocallyViaPython(linksArray, folderName, suffix)
 * Отправляем POST-запрос на http://127.0.0.1:5000/download
 * И сохраняем data.folder → lastFolderPath
 */
async function downloadLocallyViaPython(linksArray, folderName = '', suffix = '') {
  try {
    const bodyData = { folderName, suffix, files: linksArray };

    const resp = await fetch("http://127.0.0.1:5000/download", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(bodyData)
    });

    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`Ошибка локального сервера: ${resp.status} ${txt}`);
    }

    const data = await resp.json();
    showToast(`Скачано локально: ${data.count} файлов`, 'success');
    console.log('[downloadLocallyViaPython] data =', data);

    // Если сервер вернул data.folder, сохраняем
    if (data.folder) {
      localStorage.setItem('lastFolderPath', data.folder);
    }

  } catch (e) {
    console.error('[downloadLocallyViaPython] Ошибка:', e);
    showToast(`Ошибка скачивания: ${e.message}`, 'error');
    throw e;
  }
}


/* ==========================
   8. Прочее (модалки, CSV)
   ========================== */

/**
 * getPublicLinkForFile(fileObj)
 * Получаем/публикуем ссылку на Я.Диске, возвращаем прямую ссылку (.file) или public_url
 */
async function getPublicLinkForFile(fileObj) {
  try {
    const infoUrl = `https://cloud-api.yandex.net/v1/disk/resources?path=${encodeURIComponent(fileObj.path)}`;
    const headers = { Authorization: `OAuth ${YANDEX_TOKEN}` };

    // 1) Запрашиваем info
    let resp = await fetch(infoUrl, { method: 'GET', headers });
    if (!resp.ok) {
      throw new Error(`[getPublicLinkForFile] Ошибка GET info: ${fileObj.name}`);
    }
    let data = await resp.json();

    // 2) Публикуем, если нет public_url
    if (!data.public_url) {
      const pubUrl = `https://cloud-api.yandex.net/v1/disk/resources/publish?path=${encodeURIComponent(fileObj.path)}`;
      resp = await fetch(pubUrl, { method: 'PUT', headers });
      if (!resp.ok) {
        const dd = await resp.json();
        throw new Error(`[getPublicLinkForFile] Ошибка publish ${fileObj.name}: ${dd.message}`);
      }
      // Повторный запрос info
      resp = await fetch(infoUrl, { method: 'GET', headers });
      if (!resp.ok) {
        throw new Error(`[getPublicLinkForFile] Ошибка повторного GET info: ${fileObj.name}`);
      }
      data = await resp.json();
    }

    // 3) Пытаемся получить прямую ссылку (через public_key)
    if (!data.public_key) {
      console.warn('[getPublicLinkForFile] Нет public_key, возвращаем public_url');
      return data.public_url || '#';
    }

    const pubKey = data.public_key;
    const pubInfoUrl = `https://cloud-api.yandex.net/v1/disk/public/resources?public_key=${encodeURIComponent(pubKey)}`;
    resp = await fetch(pubInfoUrl, { method: 'GET', headers });
    if (!resp.ok) {
      console.warn('[getPublicLinkForFile] public_key info недоступен, возвращаем public_url');
      return data.public_url || '#';
    }

    const pubData = await resp.json();
    if (pubData.file) {
      return pubData.file; // Прямая ссылка на файл
    } else {
      console.warn('[getPublicLinkForFile] public_key не содержит "file", возвращаем public_url');
      return data.public_url || '#';
    }
  } catch (e) {
    console.warn('[getPublicLinkForFile] error:', e);
    return '#';
  }
}

/**
 * getPublicLinkForPreview(fileObj)
 * Получает/публикует файл, но всегда возвращает public_url (веб-просмотр)
 */
async function getPublicLinkForPreview(fileObj) {
  try {
    const infoUrl = `https://cloud-api.yandex.net/v1/disk/resources?path=${encodeURIComponent(fileObj.path)}`;
    const headers = { Authorization: `OAuth ${YANDEX_TOKEN}` };

    // 1) Запрашиваем инфо
    let resp = await fetch(infoUrl, { method: 'GET', headers });
    if (!resp.ok) {
      throw new Error(`[getPublicLinkForPreview] Ошибка GET info: ${fileObj.name}`);
    }
    let data = await resp.json();

    // 2) Если не опубликован — публикуем
    if (!data.public_url) {
      const pubUrl = `https://cloud-api.yandex.net/v1/disk/resources/publish?path=${encodeURIComponent(fileObj.path)}`;
      resp = await fetch(pubUrl, { method: 'PUT', headers });
      if (!resp.ok) {
        const dd = await resp.json();
        throw new Error(`[getPublicLinkForPreview] Ошибка publish ${fileObj.name}: ${dd.message}`);
      }
      // Повторный запрос info
      resp = await fetch(infoUrl, { method: 'GET', headers });
      if (!resp.ok) {
        throw new Error(`[getPublicLinkForPreview] Ошибка повторного GET info: ${fileObj.name}`);
      }
      data = await resp.json();
    }

    // 3) Возвращаем именно public_url
    if (data.public_url) {
      return data.public_url; 
    } else {
      console.warn('[getPublicLinkForPreview] Нет public_url, вернём #');
      return '#';
    }
  } catch (e) {
    console.warn('[getPublicLinkForPreview] error:', e);
    return '#';
  }
}

/**
 * getSupplyQRCodeWB()
 * Если нужно, возвращает QR-код поставки в Wildberries (пример: "WB-GI-132714007")
 */
function getSupplyQRCodeWB() {
  const itemEls = document.querySelectorAll('div.Supply-details-card__item__IquHH2pip8');
  for (const itemEl of itemEls) {
    const labelEl = itemEl.querySelector('.Supply-details-card__item-label span[data-name="Text"]');
    if (!labelEl) continue;
    if (labelEl.textContent.includes('QR-код поставки')) {
      const valEl = itemEl.querySelector('.Supply-details-card__item-text span[data-name="Text"]');
      if (valEl) {
        return valEl.textContent.trim();
      }
    }
  }
  return '';
}
// ============= СТИЛИ ДЛЯ МОДАЛКИ (CSS) =============
const modalEnhanceStyle = document.createElement('style');
modalEnhanceStyle.innerHTML = `
  .custom-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 999999;
    opacity: 0;
    animation: fadeIn 0.3s forwards;
  }
  .custom-modal {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    width: 400px;
    max-height: 70vh;
    overflow-y: auto;
    background-color: #fff;
    border-radius: 8px;
    padding: 20px 20px 40px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 1000000;
    opacity: 0;
    animation: scaleIn 0.3s forwards;
  }
  @keyframes fadeIn {
    to { opacity: 1; }
  }
  @keyframes scaleIn {
    to {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  }
  .close-button {
    position: absolute;
    top: 8px;
    right: 12px;
    border: none;
    background: transparent;
    font-size: 18px;
    cursor: pointer;
    color: #666;
  }
  .close-button:hover {
    color: #111;
  }
  .custom-modal h3 {
    margin: 0 0 10px;
    font-size: 18px;
  }
  .custom-modal p {
    margin: 0 0 15px;
  }
  .list-container {
    margin-bottom: 20px;
  }
  .list-item {
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .button-row {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }
  button.custom-btn {
    border: none;
    border-radius: 5px;
    padding: 8px 14px;
    font-size: 14px;
    cursor: pointer;
  }
  button.custom-btn:hover {
    opacity: 0.9;
  }
  .btn-cancel {
    background: #888;
    color: #fff;
  }
  .btn-confirm {
    background: #6495ED;
    color: #fff;
  }
  .button-link {
    display: inline-block;
    padding: 8px 12px;
    background-color: #6495ED;
    color: #fff;
    border-radius: 4px;
    text-decoration: none;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
  }
  .button-link:hover {
    background-color: #558ad6;
  }
`;
document.head.appendChild(modalEnhanceStyle);

/**
 * Модальное окно showIpModal(...)
 */
/**
 * showIpModal(matchedFiles, article, number)
 * Отображает модальное окно для «оранжевых» файлов, где:
 * - Есть чекбоксы для выбора нужных файлов.
 * - Кнопка «Открыть» (просмотр в Я.Диске) — без скачивания.
 * - Кнопка «Подтвердить» возвращает список выбранных (чекбоксы).
 */
function showIpModal(matchedFiles, article, number) {
  return new Promise((resolve) => {
    // 1) Создаём «оверлей» — затемнённый фон
    const overlay = document.createElement('div');
    overlay.classList.add('custom-overlay');
    document.body.appendChild(overlay);

    // 2) Создаём «модальное окно»
    const modal = document.createElement('div');
    modal.classList.add('custom-modal');
    overlay.appendChild(modal);

    // 3) Заголовок с артикулом
    const titleEl = document.createElement('h3');
    titleEl.textContent = `Артикул: ${article}`;
    modal.appendChild(titleEl);

    // 4) Доп. пояснение
    const infoEl = document.createElement('p');
    infoEl.textContent = 'Несколько файлов. Отметьте нужные для скачивания:';
    modal.appendChild(infoEl);

    // 5) Контейнер для списка «строк» (чекбоксы + кнопки «Открыть»)
    const listContainer = document.createElement('div');
    listContainer.classList.add('list-container');

    // Перебираем все matchedFiles и создаём «строку» для каждого
    matchedFiles.forEach((fileObj) => {
      const rowEl = document.createElement('div');
      rowEl.classList.add('list-item');

      // --- Чекбокс ---
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.value = fileObj.name; 
      // (можно добавить: checkbox.checked = true, если нужно «выделять» по умолчанию)

      // --- Надпись (имя файла) ---
      const label = document.createElement('span');
      label.textContent = fileObj.name;

      // --- Кнопка «Открыть» (для просмотра) ---
      const openLink = document.createElement('a');
      openLink.classList.add('button-link');
      openLink.textContent = 'Открыть';
      openLink.href = '#';
      openLink.target = '_blank';
      openLink.style.marginLeft = 'auto';

      // При клике — получаем public_url для просмотра (например, getPublicLinkForPreview)
      openLink.onclick = async (e) => {
        e.preventDefault();
        // например, если есть функция getPublicLinkForPreview(...)
        const previewUrl = await getPublicLinkForPreview(fileObj); 
        if (previewUrl && previewUrl !== '#') {
          openLink.href = previewUrl;
          window.open(previewUrl, '_blank');
        } else {
          alert(`Не удалось получить ссылку для просмотра: ${fileObj.name}`);
        }
      };

      // Добавляем элементы в "строку"
      rowEl.appendChild(checkbox);
      rowEl.appendChild(label);
      rowEl.appendChild(openLink);
      // Добавляем "строку" в контейнер
      listContainer.appendChild(rowEl);
    });

    // Вставляем контейнер в модалку
    modal.appendChild(listContainer);

    // 6) Нижняя панель с кнопками «Отмена» / «Подтвердить»
    const buttonRow = document.createElement('div');
    buttonRow.classList.add('button-row');

    // Кнопка «Отмена»
    const cancelBtn = document.createElement('button');
    cancelBtn.classList.add('custom-btn', 'btn-cancel');
    cancelBtn.textContent = 'Отмена';
    cancelBtn.onclick = () => {
      cleanup();
      resolve([]); 
    };
    buttonRow.appendChild(cancelBtn);

    // Кнопка «Подтвердить»
    const confirmBtn = document.createElement('button');
    confirmBtn.classList.add('custom-btn', 'btn-confirm');
    confirmBtn.textContent = 'Подтвердить';
    confirmBtn.onclick = () => {
      // Собираем все отмеченные чекбоксы
      const checkedNames = Array.from(
        listContainer.querySelectorAll('input[type="checkbox"]:checked')
      ).map(el => el.value);

      // Фильтруем matchedFiles, оставляя только те, чьи имена выбраны
      const chosen = matchedFiles.filter(f => checkedNames.includes(f.name));
      cleanup();
      resolve(chosen);  // Возвращаем выбранные файлы
    };
    buttonRow.appendChild(confirmBtn);

    modal.appendChild(buttonRow);

    // 7) Функция очистки (закрыть модалку)
    function cleanup() {
      if (overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
    }
  });
}

// =========================
// 8. ЭКСПОРТ CSV
// =========================
function formatDateString(dateStr) {
  if(!dateStr) return '';
  const d = new Date(dateStr);
  const dd = String(d.getDate()).padStart(2,'0');
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const yy = d.getFullYear();
  const hh = String(d.getHours()).padStart(2,'0');
  const mn = String(d.getMinutes()).padStart(2,'0');
  return `${dd}.${mm}.${yy} ${hh}:${mn}`;
}

function exportToCSV() {
  const sorted = [...database].sort((a,b) => new Date(b.uploadedAt) - new Date(a.uploadedAt));
  const BOM = '\uFEFF';
  let csv = BOM + "Название;Дата\n";
  sorted.forEach(file => {
    const safeName = `${file.name.replace(/"/g,'""')}`;
    const dateStr  = `${formatDateString(file.uploadedAt)}`;
    csv += `${safeName};${dateStr}\n`;
  });
  const blob = new Blob([csv], { type:'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', 'combined_files_database.csv');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}


/* ==========================
   9. СПИННЕР-КАУНТДАУН
   ========================== */
let spinnerTimer = null;

function startSyncSpinnerCountdown(seconds) {
  if (!autoSyncEnabled) return;

  const spinnerEl = document.getElementById('sync-spinner');
  if (!spinnerEl) {
    console.warn('Спиннер (#sync-spinner) не найден!');
    return;
  }
  stopSyncSpinner();

  spinnerEl.style.animation = 'spin 10s linear infinite';

  let angle = 0; 
  let remain = seconds;
  const angleStep = 360 / seconds;

  spinnerTimer = setInterval(() => {
    if (!autoSyncEnabled) {
      stopSyncSpinner();
      return;
    }
    remain--;
    angle += angleStep;
    spinnerEl.style.transform = `rotate(${angle}deg)`;

    if (remain <= 0) {
      clearInterval(spinnerTimer);
      spinnerTimer = null;
      syncFilesToDatabase().then(() => {
        startSyncSpinnerCountdown(60);
      });
    }
  }, 1000);
}

function stopSyncSpinner() {
  if (spinnerTimer) {
    clearInterval(spinnerTimer);
    spinnerTimer = null;
  }
  const spinnerEl = document.getElementById('sync-spinner');
  if (spinnerEl) {
    spinnerEl.style.animation = 'none';
    spinnerEl.style.transform = 'rotate(0deg)';
  }
}


/* ==========================
   10. ИНИЦИАЛИЗАЦИЯ
   ========================== */
(async function init() {
  console.log('[content-all.js] init on', window.location.href);

  // 1) Загружаем «виртуальную» базу (через background)
  await loadDataFromBackground();

  // 2) Создаём панель UI
  createUI();

  // 3) Первая синхронизация
  await syncFilesToDatabase();

  // 4) Запускаем «спиннер-обратный отсчёт»
  startSyncSpinnerCountdown(60);

  // 5) Слушаем клики по «строчным» чекбоксам
  document.addEventListener('change', (e) => {
    if (e.target.type === 'checkbox') {
      if (isOzon) {
        updateSelectedArticlesOzon(e.target);
      } else if (isWB) {
        updateSelectedArticlesWB(e.target);
      }
    }
  });

  // (A) Объявляем здесь функцию «attachMainWbCheckbox» 
  //     (Function Declaration), чтобы мы могли вызвать её ниже
  function attachMainWbCheckbox() {
    // Работает только на WB
    if (!isWB) return;

    // Ищем #checkbox-all (уже вёрстка WB)
    const mainCheckbox = document.querySelector('#checkbox-all');
    if (!mainCheckbox) {
      console.warn('Не нашли элемент #checkbox-all (WB)');
      return;
    }

    // Навешиваем «change»
    mainCheckbox.addEventListener('change', (e) => {
      const checked = e.target.checked;
      console.log('[WB main checkbox] changed =>', checked);

      // Вызываем handleSelectAllWB(checked) — см. «Блок 7»
      // (Убедитесь, что handleSelectAllWB объявлена либо глобально,
      //  либо выше этого кода, либо в Блоке 7, но уже загружена)
      handleSelectAllWB(checked);
    });
  }

  // (B) Вызываем attachMainWbCheckbox(), чтобы «главный» чекбокс работал
  attachMainWbCheckbox();

  // (C) Подсветка при возврате на вкладку
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      autoHighlightAllArticles();
      console.log('[content-all.js] Подсветка при возврате на вкладку');
    }
  });

  // (D) Подсветка при динамической подгрузке
  initMutationObserver();

})(); // <-- конец IIFE


///////////////////////////
// A) Функция updateCounter
///////////////////////////
function updateCounter() {
  const countSpan = document.getElementById('article-counter');
  if (!countSpan) return;

  // Считаем уникальные артикулы
  const uniqueArticles = new Set(selectedArticles.map(item => item.article));
  countSpan.textContent = `Выбрано: ${uniqueArticles.size}`;
}


////////////////////////////
// B) ЛОГИКА ЧЕКБОКСОВ (Ozon)
////////////////////////////
function extractQuantity(text) {
  const match = text.match(/(\d+)\s*шт/);
  return match ? parseInt(match[1], 10) : 1;
}

function updateSelectedArticlesOzon(checkbox) {
  const row = checkbox.closest('tr');
  if (!row) return;

  const articleLinks = row.querySelectorAll('a.link-module_link_91e5F');
  const quantitySpan = row.querySelector('span.quantity-selector');
  const qtyRaw = quantitySpan ? quantitySpan.textContent.trim() : '1 шт.';
  const quantity = extractQuantity(qtyRaw);

  if (checkbox.checked) {
    articleLinks.forEach(articleLink => {
      const articleText = articleLink.textContent.trim();
      for (let i = 0; i < quantity; i++) {
        const uniqueId = `ozonChk_${articleText}_${i + 1}`;
        selectedArticles.push({
          id: uniqueId,
          article: articleText,
          number: 'без номера'
        });
      }
    });
  } else {
    articleLinks.forEach(articleLink => {
      const articleText = articleLink.textContent.trim();
      selectedArticles = selectedArticles.filter(
        item => !item.id.includes(`ozonChk_${articleText}_`)
      );
    });
  }

  updateCounter();
  console.log('[OZON] Выбрано артикулов:', selectedArticles);
}


/////////////////////////////
// C) ЛОГИКА ЧЕКБОКСОВ (WB)
/////////////////////////////
function updateSelectedArticlesWB(checkbox) {
  const cardEl =
    checkbox.closest('div.Table-row-view__wk354Ab8Rh') ||
    checkbox.closest('div.Tasks-card-view__card-content');
  if (!cardEl) return;

  // Пытаемся получить артикул
  const baseArticle = getArticleFromRowWB(cardEl);
  if (baseArticle === '—') {
    console.log('Артикул не найден в карточке:', cardEl);
    return;
  }

  // Формируем уникальный ID по чекбоксу и артикулу
  const itemId = `${checkbox.id}_${baseArticle}`;

  if (checkbox.checked) {
    // Проверяем, нет ли уже такого элемента в selectedArticles
    const exists = selectedArticles.some(item => item.id === itemId);
    if (!exists) {
      selectedArticles.push({
        id: itemId,
        article: baseArticle,
    
      });
    }
  } else {
    // Убираем из массива, если чекбокс снят
    selectedArticles = selectedArticles.filter(item => item.id !== itemId);
  }

  // Обновляем счётчик, логируем (по желанию)
  updateCounter();
  console.log(`[WB] Выбрано артикулов: (${selectedArticles.length})`, selectedArticles);
}
